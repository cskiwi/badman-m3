"""
Indicates exactly one field must be supplied and this field must not be `null`.
"""
directive @oneOf on INPUT_OBJECT

input AddToCartInput {
  items: [CartItemInput!]!
  sessionId: String
  tournamentId: ID!
}

input AssignEntriesToDrawInput {
  """Draw ID to assign entries to"""
  drawId: ID!

  """Entry IDs to assign"""
  entryIds: [ID!]!
}

input AssignEntryToDrawInput {
  """Draw ID to assign entry to"""
  drawId: ID!

  """Entry ID to assign"""
  entryId: ID!
}

input AutoSeedDrawInput {
  """Draw ID to auto-seed"""
  drawId: ID!

  """Method to use for seeding"""
  method: SeedingMethod! = BY_RANKING
}

"""Player availability for events"""
type Availability {
  createdAt: DateTime!
  days: String!
  exceptions: String
  id: ID!
  locationId: String
  season: Float!
  updatedAt: DateTime
}

input AvailabilityArgs {
  order: AvailabilitySortOrder
  skip: Int = 0
  take: Int
  where: [AvailabilityWhereInput!]
}

input AvailabilitySortOrder {
  createdAt: SortDirection
  days: SortDirection
  exceptions: SortDirection
  locationId: SortDirection
  season: SortDirection
  updatedAt: SortDirection
}

input AvailabilityWhereInput {
  AND: [AvailabilityWhereInput!]
  OR: [AvailabilityWhereInput!]
  createdAt: DateWhereOperators
  days: StringWhereOperators
  exceptions: StringWhereOperators
  locationId: StringWhereOperators
  season: NumberWhereOperators
  updatedAt: DateWhereOperators
}

input BooleanWhereOperators {
  eq: Boolean
  isNull: Boolean
  ne: Boolean
  raw: String
}

input CartItemInput {
  guestInfo: GuestInfoInput
  notes: String
  preferredPartnerId: ID
  subEventId: ID!
}

"""A Claim"""
type Claim {
  category: String
  createdAt: DateTime
  description: String
  id: ID!
  name: String
  players: [Player!]
  roles: [Role!]
  type: String
  updatedAt: DateTime
}

input ClaimArgs {
  order: ClaimSortOrder
  skip: Int = 0
  take: Int
  where: [ClaimWhereInput!]
}

input ClaimSortOrder {
  category: SortDirection
  createdAt: SortDirection
  description: SortDirection
  name: SortDirection
  type: SortDirection
  updatedAt: SortDirection
}

input ClaimWhereInput {
  AND: [ClaimWhereInput!]
  OR: [ClaimWhereInput!]
  category: StringWhereOperators
  createdAt: DateWhereOperators
  description: StringWhereOperators
  name: StringWhereOperators
  type: StringWhereOperators
  updatedAt: DateWhereOperators
}

"""A Club"""
type Club {
  abbreviation: String!
  clubId: Float
  clubPlayerMemberships: ClubPlayerMembership!
  contactCompetition: String
  country: String
  createdAt: DateTime!
  distinctSeasons: [Float!]
  fullName: String
  id: ID!
  name: String!
  slug: String!
  state: String
  teamName: String!
  teams(args: TeamArgs): [Team!]!
  tournamentEvents(args: TournamentEventArgs): [TournamentEvent!]
  updatedAt: DateTime
  useForTeamName: String!
}

input ClubArgs {
  order: ClubSortOrder
  skip: Int = 0
  take: Int
  where: [ClubWhereInput!]
}

type ClubPlayerMembership {
  active: Boolean!
  club(args: ClubArgs): Club
  clubId: String!
  confirmed: Boolean!
  end: DateTime
  id: ID!
  membershipType: String!
  player(args: PlayerArgs): Player
  playerId: String!
  start: DateTime!
}

input ClubPlayerMembershipArgs {
  order: ClubPlayerMembershipSortOrder
  skip: Int = 0
  take: Int
  where: [ClubPlayerMembershipWhereInput!]
}

input ClubPlayerMembershipSortOrder {
  active: SortDirection
  clubId: SortDirection
  confirmed: SortDirection
  end: SortDirection
  membershipType: SortDirection
  playerId: SortDirection
  start: SortDirection
}

input ClubPlayerMembershipWhereInput {
  AND: [ClubPlayerMembershipWhereInput!]
  OR: [ClubPlayerMembershipWhereInput!]
  clubId: StringWhereOperators
  confirmed: BooleanWhereOperators
  end: DateWhereOperators
  membershipType: StringWhereOperators
  playerId: StringWhereOperators
  start: DateWhereOperators
}

input ClubSortOrder {
  abbreviation: SortDirection
  clubId: SortDirection
  clubPlayerMemberships: SortDirection
  contactCompetition: SortDirection
  country: SortDirection
  createdAt: SortDirection
  fullName: SortDirection
  name: SortDirection
  slug: SortDirection
  state: SortDirection
  teamName: SortDirection
  teams: SortDirection
  updatedAt: SortDirection
  useForTeamName: SortDirection
}

input ClubWhereInput {
  AND: [ClubWhereInput!]
  OR: [ClubWhereInput!]
  abbreviation: StringWhereOperators
  clubId: NumberWhereOperators
  contactCompetition: StringWhereOperators
  country: StringWhereOperators
  createdAt: DateWhereOperators
  fullName: StringWhereOperators
  name: StringWhereOperators
  slug: StringWhereOperators
  state: StringWhereOperators
  teamName: StringWhereOperators
  updatedAt: DateWhereOperators
  useForTeamName: StringWhereOperators
}

"""A Comment"""
type Comment {
  clubId: String
  createdAt: DateTime!
  id: ID!
  linkId: String
  linkType: String
  message: String!
  playerId: String
  updatedAt: DateTime
}

input CommentArgs {
  order: CommentSortOrder
  skip: Int = 0
  take: Int
  where: [CommentWhereInput!]
}

input CommentSortOrder {
  clubId: SortDirection
  createdAt: SortDirection
  linkId: SortDirection
  linkType: SortDirection
  message: SortDirection
  playerId: SortDirection
  updatedAt: SortDirection
}

input CommentWhereInput {
  AND: [CommentWhereInput!]
  OR: [CommentWhereInput!]
  clubId: StringWhereOperators
  createdAt: DateWhereOperators
  linkId: StringWhereOperators
  linkType: StringWhereOperators
  message: StringWhereOperators
  playerId: StringWhereOperators
  updatedAt: DateWhereOperators
}

"""A Team Assembly in Competition"""
type CompetitionAssembly {
  assembly: JSONObject
  captainId: String
  createdAt: DateTime!
  description: String
  encounterCompetition: CompetitionEncounter
  encounterId: String
  id: ID!
  isComplete: Boolean
  playerId: String
  teamId: String
  updatedAt: DateTime
}

input CompetitionAssemblyArgs {
  order: CompetitionAssemblySortOrder
  skip: Int = 0
  take: Int
  where: [CompetitionAssemblyWhereInput!]
}

input CompetitionAssemblySortOrder {
  captainId: SortDirection
  createdAt: SortDirection
  encounterId: SortDirection
  playerId: SortDirection
  teamId: SortDirection
  updatedAt: SortDirection
}

input CompetitionAssemblyWhereInput {
  AND: [CompetitionAssemblyWhereInput!]
  OR: [CompetitionAssemblyWhereInput!]
}

"""A Competition Draw"""
type CompetitionDraw {
  competitionEncounters(args: CompetitionEncounterArgs): [CompetitionEncounter!]
  competitionSubEvent: CompetitionSubEvent
  createdAt: DateTime!
  fallers: Int!
  id: ID!
  lastSync: DateTime
  name: String
  risers: Int!
  size: Int
  subeventId: String
  type: String
  updatedAt: DateTime
  visualCode: String
}

input CompetitionDrawArgs {
  order: CompetitionDrawSortOrder
  skip: Int = 0
  take: Int
  where: [CompetitionDrawWhereInput!]
}

input CompetitionDrawSortOrder {
  createdAt: SortDirection
  fallers: SortDirection
  lastSync: SortDirection
  name: SortDirection
  risers: SortDirection
  size: SortDirection
  subeventId: SortDirection
  type: SortDirection
  updatedAt: SortDirection
}

input CompetitionDrawWhereInput {
  AND: [CompetitionDrawWhereInput!]
  OR: [CompetitionDrawWhereInput!]
  lastSync: DateWhereOperators
}

"""A Competition Encounter"""
type CompetitionEncounter {
  accepted: Boolean!
  acceptedById: String
  acceptedOn: DateTime
  assemblies(args: CompetitionAssemblyArgs): [CompetitionAssembly!]
  awayCaptainAccepted: Boolean
  awayCaptainPresent: Boolean
  awayScore: Float
  awayTeam: Team
  awayTeamId: String
  createdAt: DateTime!
  date: DateTime
  drawCompetition: CompetitionDraw
  drawId: String
  endHour: String
  enteredById: String
  enteredOn: DateTime
  finished: Boolean!
  gameLeaderAccepted: Boolean
  gameLeaderId: String
  gameLeaderPresent: Boolean
  games(args: GameArgs): [Game!]
  homeCaptainAccepted: Boolean
  homeCaptainPresent: Boolean
  homeScore: Float
  homeTeam: Team
  homeTeamId: String
  id: ID!
  locationId: String
  originalDate: DateTime
  originalLocationId: String
  shuttle: String
  startHour: String
  synced: DateTime
  tempAwayCaptainId: String
  tempHomeCaptainId: String
  updatedAt: DateTime
  visualCode: String
}

input CompetitionEncounterArgs {
  order: CompetitionEncounterSortOrder
  skip: Int = 0
  take: Int
  where: [CompetitionEncounterWhereInput!]
}

"""Changes made to a competition encounter"""
type CompetitionEncounterChange {
  accepted: Boolean!
  changeDates: [CompetitionEncounterChangeDate!]
  createdAt: DateTime!
  encounterId: String
  id: ID!
  updatedAt: DateTime
}

"""Date changes for a competition encounter"""
type CompetitionEncounterChangeDate {
  availabilityAway: String
  availabilityHome: String
  createdAt: DateTime!
  date: DateTime!
  encounterChange: CompetitionEncounterChange!
  encounterChangeId: String
  id: ID!
  locationId: String
  selected: Boolean
  updatedAt: DateTime
}

input CompetitionEncounterSortOrder {
  accepted: SortDirection
  acceptedById: SortDirection
  acceptedOn: SortDirection
  awayScore: SortDirection
  awayTeamId: SortDirection
  createdAt: SortDirection
  date: SortDirection
  drawId: SortDirection
  enteredById: SortDirection
  enteredOn: SortDirection
  finished: SortDirection
  gameLeaderId: SortDirection
  homeScore: SortDirection
  homeTeamId: SortDirection
  locationId: SortDirection
  originalDate: SortDirection
  originalLocationId: SortDirection
  synced: SortDirection
  tempAwayCaptainId: SortDirection
  tempHomeCaptainId: SortDirection
  updatedAt: SortDirection
}

input CompetitionEncounterWhereInput {
  AND: [CompetitionEncounterWhereInput!]
  OR: [CompetitionEncounterWhereInput!]
  accepted: BooleanWhereOperators
  acceptedById: StringWhereOperators
  acceptedOn: DateWhereOperators
  awayScore: NumberWhereOperators
  awayTeamId: StringWhereOperators
  createdAt: DateWhereOperators
  date: DateWhereOperators
  drawId: StringWhereOperators
  enteredById: StringWhereOperators
  enteredOn: DateWhereOperators
  finished: BooleanWhereOperators
  gameLeaderId: StringWhereOperators
  homeScore: NumberWhereOperators
  homeTeamId: StringWhereOperators
  locationId: StringWhereOperators
  originalDate: DateWhereOperators
  originalLocationId: StringWhereOperators
  synced: DateWhereOperators
  tempAwayCaptainId: StringWhereOperators
  tempHomeCaptainId: StringWhereOperators
  updatedAt: DateWhereOperators
}

"""A CompetitionEvent"""
type CompetitionEvent {
  changeCloseDatePeriod1: DateTime
  changeCloseDatePeriod2: DateTime
  changeCloseRequestDatePeriod1: DateTime
  changeCloseRequestDatePeriod2: DateTime
  changeOpenDate: DateTime
  checkEncounterForFilledIn: Boolean!
  closeDate: DateTime
  competitionSubEvents(args: CompetitionSubEventArgs): [CompetitionSubEvent!]
  contactEmail: String
  contactId: String
  country: String
  createdAt: DateTime!
  exceptions: [EventException!]
  id: ID!
  infoEvents: [InfoEvent!]
  lastSync: DateTime
  meta: MetaEventCompetition
  name: String
  official: Boolean!
  openDate: DateTime
  season: Int
  slug: String
  started: Boolean
  state: String
  teamMatcher: String
  type: String
  updatedAt: DateTime
  usedRankingAmount: Int!
  usedRankingUnit: String!
  visualCode: String
}

input CompetitionEventArgs {
  order: CompetitionEventSortOrder
  skip: Int = 0
  take: Int
  where: [CompetitionEventWhereInput!]
}

input CompetitionEventSortOrder {
  changeCloseDatePeriod1: SortDirection
  changeCloseDatePeriod2: SortDirection
  changeCloseRequestDatePeriod1: SortDirection
  changeCloseRequestDatePeriod2: SortDirection
  changeOpenDate: SortDirection
  checkEncounterForFilledIn: SortDirection
  closeDate: SortDirection
  contactEmail: SortDirection
  contactId: SortDirection
  country: SortDirection
  createdAt: SortDirection
  exceptions: SortDirection
  infoEvents: SortDirection
  lastSync: SortDirection
  meta: SortDirection
  name: SortDirection
  official: SortDirection
  openDate: SortDirection
  season: SortDirection
  slug: SortDirection
  started: SortDirection
  state: SortDirection
  teamMatcher: SortDirection
  type: SortDirection
  updatedAt: SortDirection
  usedRankingAmount: SortDirection
  usedRankingUnit: SortDirection
  visualCode: SortDirection
}

input CompetitionEventWhereInput {
  AND: [CompetitionEventWhereInput!]
  OR: [CompetitionEventWhereInput!]
  changeOpenDate: DateWhereOperators
  closeDate: DateWhereOperators
  contactEmail: StringWhereOperators
  contactId: StringWhereOperators
  createdAt: DateWhereOperators
  exceptions: StringWhereOperators
  infoEvents: StringWhereOperators
  lastSync: DateWhereOperators
  meta: StringWhereOperators
  name: StringWhereOperators
  openDate: DateWhereOperators
  season: NumberWhereOperators
  started: BooleanWhereOperators
  updatedAt: DateWhereOperators
  usedRankingAmount: NumberWhereOperators
  usedRankingUnit: StringWhereOperators
}

"""Membership between group and sub-event in competition"""
type CompetitionGroupSubEventMembership {
  createdAt: DateTime!
  groupId: String!
  id: ID!
  isActive: Boolean
  sortOrder: Float
  subEventId: String!
  updatedAt: DateTime
}

"""A Sub Event Competition"""
type CompetitionSubEvent {
  competitionDraws(args: CompetitionDrawArgs): [CompetitionDraw!]
  competitionEvent: CompetitionEvent
  createdAt: DateTime!
  eventId: String
  eventType: String
  gameTypeId: Int
  genderId: Int
  id: ID!
  lastSync: DateTime
  level: Int
  maxBaseIndex: Int
  maxLevel: Int
  minBaseIndex: Int
  name: String
  paraClassId: Int
  updatedAt: DateTime
  visualCode: String
}

input CompetitionSubEventArgs {
  order: CompetitionSubEventSortOrder
  skip: Int = 0
  take: Int
  where: [CompetitionSubEventWhereInput!]
}

input CompetitionSubEventSortOrder {
  createdAt: SortDirection
  eventId: SortDirection
  eventType: SortDirection
  gameTypeId: SortDirection
  genderId: SortDirection
  lastSync: SortDirection
  level: SortDirection
  maxBaseIndex: SortDirection
  maxLevel: SortDirection
  minBaseIndex: SortDirection
  name: SortDirection
  paraClassId: SortDirection
  updatedAt: SortDirection
  visualCode: SortDirection
}

input CompetitionSubEventWhereInput {
  AND: [CompetitionSubEventWhereInput!]
  OR: [CompetitionSubEventWhereInput!]
  createdAt: DateWhereOperators
  eventId: StringWhereOperators
  eventType: StringWhereOperators
  gameTypeId: NumberWhereOperators
  genderId: NumberWhereOperators
  lastSync: DateWhereOperators
  level: NumberWhereOperators
  maxLevel: NumberWhereOperators
  minBaseIndex: NumberWhereOperators
  name: StringWhereOperators
  paraClassId: NumberWhereOperators
  updatedAt: DateWhereOperators
  visualCode: StringWhereOperators
}

"""A court at a location"""
type Court {
  createdAt: DateTime!
  id: ID!
  locationId: String
  name: String
  updatedAt: DateTime
}

input CourtArgs {
  order: CourtSortOrder
  skip: Int = 0
  take: Int
  where: [CourtWhereInput!]
}

input CourtSortOrder {
  createdAt: SortDirection
  locationId: SortDirection
  name: SortDirection
  updatedAt: SortDirection
}

type CourtStatus {
  courtId: ID!
  courtName: String!
  currentGame: Game
  nextGame: Game
  status: String!
}

input CourtWhereInput {
  AND: [CourtWhereInput!]
  OR: [CourtWhereInput!]
  createdAt: DateWhereOperators
  locationId: StringWhereOperators
  name: StringWhereOperators
  updatedAt: DateWhereOperators
}

input CreateTournamentDrawInput {
  name: String
  size: Int

  """Sub-event ID this draw belongs to"""
  subEventId: ID!
  type: String
}

"""Scheduled job configuration"""
type CronJob {
  createdAt: DateTime!
  cronExpression: String!
  description: String
  failureCount: Float
  id: ID!
  isActive: Boolean!
  jobFunction: String!
  lastError: String
  lastRun: DateTime
  lastStatus: String
  name: String!
  nextRun: DateTime
  parameters: String
  runCount: Float
  updatedAt: DateTime
}

input CronJobArgs {
  order: CronJobSortOrder
  skip: Int = 0
  take: Int
  where: [CronJobWhereInput!]
}

input CronJobSortOrder {
  createdAt: SortDirection
  cronExpression: SortDirection
  description: SortDirection
  failureCount: SortDirection
  isActive: SortDirection
  jobFunction: SortDirection
  lastError: SortDirection
  lastRun: SortDirection
  lastStatus: SortDirection
  name: SortDirection
  nextRun: SortDirection
  parameters: SortDirection
  runCount: SortDirection
  updatedAt: SortDirection
}

input CronJobWhereInput {
  AND: [CronJobWhereInput!]
  OR: [CronJobWhereInput!]
  createdAt: DateWhereOperators
  cronExpression: StringWhereOperators
  description: StringWhereOperators
  failureCount: NumberWhereOperators
  isActive: BooleanWhereOperators
  jobFunction: StringWhereOperators
  lastError: StringWhereOperators
  lastRun: DateWhereOperators
  lastStatus: StringWhereOperators
  name: StringWhereOperators
  nextRun: DateWhereOperators
  parameters: StringWhereOperators
  runCount: NumberWhereOperators
  updatedAt: DateWhereOperators
}

"""
A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format.
"""
scalar DateTime

input DateWhereOperators {
  between: [DateTime!]
  eq: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  isNull: Boolean
  lt: DateTime
  lte: DateTime
  ne: DateTime
  nin: [DateTime!]
  raw: String
}

"""
Input for enrolling a guest (non-registered player) in a tournament sub-event
"""
input EnrollGuestInput {
  """Guest email address"""
  guestEmail: String!

  """Guest name"""
  guestName: String!

  """Guest phone number"""
  guestPhone: String

  """Optional notes for the enrollment"""
  notes: String

  """Preferred partner player ID (for doubles)"""
  preferredPartnerId: ID

  """Tournament sub-event ID to enroll in"""
  tournamentSubEventId: ID!
}

"""Input for enrolling an authenticated player in a tournament sub-event"""
input EnrollPlayerInput {
  """Optional notes for the enrollment"""
  notes: String

  """Preferred partner player ID (for doubles)"""
  preferredPartnerId: ID

  """Tournament sub-event ID to enroll in"""
  tournamentSubEventId: ID!
}

"""A shopping cart session for multi-event tournament enrollment"""
type EnrollmentSession {
  completedAt: DateTime
  createdAt: DateTime!
  expiresAt: DateTime!
  id: ID!
  ipAddress: String
  items: [EnrollmentSessionItem!]
  player: Player
  playerId: String
  sessionKey: String!
  status: String!
  totalSubEvents: Int!
  tournamentEvent: TournamentEvent
  tournamentEventId: String
  updatedAt: DateTime
  userAgent: String
}

input EnrollmentSessionArgs {
  order: EnrollmentSessionSortOrder
  skip: Int = 0
  take: Int
  where: [EnrollmentSessionWhereInput!]
}

"""A single sub-event selection within an enrollment cart"""
type EnrollmentSessionItem {
  createdAt: DateTime!
  guestEmail: String
  guestName: String
  guestPhone: String
  id: ID!
  isGuestEnrollment: Boolean!
  notes: String
  preferredPartner: Player
  preferredPartnerId: String
  session: EnrollmentSession!
  sessionId: String!
  tournamentSubEvent: TournamentSubEvent!
  tournamentSubEventId: String!
  updatedAt: DateTime
  validationErrors: String
  validationStatus: String!
}

input EnrollmentSessionSortOrder {
  completedAt: SortDirection
  createdAt: SortDirection
  expiresAt: SortDirection
  ipAddress: SortDirection
  playerId: SortDirection
  sessionKey: SortDirection
  status: SortDirection
  totalSubEvents: SortDirection
  tournamentEventId: SortDirection
  updatedAt: SortDirection
  userAgent: SortDirection
}

input EnrollmentSessionWhereInput {
  AND: [EnrollmentSessionWhereInput!]
  OR: [EnrollmentSessionWhereInput!]
  completedAt: DateWhereOperators
  createdAt: DateWhereOperators
  expiresAt: DateWhereOperators
  ipAddress: StringWhereOperators
  playerId: StringWhereOperators
  sessionKey: StringWhereOperators
  status: StringWhereOperators
  totalSubEvents: NumberWhereOperators
  tournamentEventId: StringWhereOperators
  updatedAt: DateWhereOperators
  userAgent: StringWhereOperators
}

"""Status of a tournament enrollment"""
enum EnrollmentStatus {
  CANCELLED
  CONFIRMED
  PENDING
  WAITING_LIST
  WITHDRAWN
}

"""Player or team entry in an event"""
type Entry {
  competitionDraw: CompetitionDraw
  competitionSubEvent: CompetitionSubEvent
  createdAt: DateTime!
  date: DateTime
  drawId: ID
  enrollmentId: String
  entryType: String
  id: ID!
  meta: EntryMeta
  player1: Player
  player1Id: String
  player2: Player
  player2Id: String
  seed: Float
  sendOn: DateTime
  standing: Standing
  subEventId: String
  team: Team
  teamId: String
  tournamentDraw: TournamentDraw
  tournamentSubEvent: TournamentSubEvent
  updatedAt: DateTime
}

input EntryArgs {
  order: EntrySortOrder
  skip: Int = 0
  take: Int
  where: [EntryWhereInput!]
}

type EntryCompetition {
  players: [EntryCompetitionPlayer!]
  teamIndex: Float
}

type EntryCompetitionPlayer {
  double: Float
  gender: String
  id: String
  levelExceptionGiven: Boolean
  levelExceptionReason: String
  levelExceptionRequested: Boolean
  mix: Float
  player: String
  single: Float
}

type EntryMeta {
  competition: EntryCompetition
  tournament: EntryTournament
}

input EntrySortOrder {
  createdAt: SortDirection
  date: SortDirection
  drawId: SortDirection
  enrollmentId: SortDirection
  entryType: SortDirection
  meta: SortDirection
  player1Id: SortDirection
  player2Id: SortDirection
  seed: SortDirection
  sendOn: SortDirection
  subEventId: SortDirection
  teamId: SortDirection
  updatedAt: SortDirection
}

type EntryTournament {
  place: Float
}

input EntryWhereInput {
  AND: [EntryWhereInput!]
  OR: [EntryWhereInput!]
  createdAt: DateWhereOperators
  date: DateWhereOperators
  drawId: IdWhereOperators
  enrollmentId: StringWhereOperators
  entryType: StringWhereOperators
  meta: StringWhereOperators
  player1Id: StringWhereOperators
  player2Id: StringWhereOperators
  seed: NumberWhereOperators
  sendOn: DateWhereOperators
  subEventId: StringWhereOperators
  teamId: StringWhereOperators
  updatedAt: DateWhereOperators
}

"""Exception for event scheduling"""
type EventException {
  courts: Int
  end: DateTime
  start: DateTime
}

"""A FAQ entry"""
type Faq {
  answer: String
  createdAt: DateTime!
  id: ID!
  question: String
  updatedAt: DateTime
}

input FaqArgs {
  order: FaqSortOrder
  skip: Int = 0
  take: Int
  where: [FaqWhereInput!]
}

input FaqSortOrder {
  answer: SortDirection
  createdAt: SortDirection
  question: SortDirection
  updatedAt: SortDirection
}

input FaqWhereInput {
  AND: [FaqWhereInput!]
  OR: [FaqWhereInput!]
  answer: StringWhereOperators
  createdAt: DateWhereOperators
  question: StringWhereOperators
  updatedAt: DateWhereOperators
}

"""A Game"""
type Game {
  actualEndTime: DateTime
  actualStartTime: DateTime
  competitionEncounter: CompetitionEncounter
  courtId: String
  createdAt: DateTime!
  gamePlayerMemberships(args: GamePlayerMembershipArgs): [GamePlayerMembership!]
  gameType: String
  id: ID!
  linkId: String!
  linkType: String!
  order: Float
  playedAt: DateTime
  rankingPoints(args: RankingPointArgs): [RankingPoint!]
  round: String
  scheduleSlotId: ID
  scheduledTime: DateTime
  set1Team1: Float
  set1Team2: Float
  set2Team1: Float
  set2Team2: Float
  set3Team1: Float
  set3Team2: Float
  status: String
  tournamentDraw: TournamentDraw
  updatedAt: DateTime
  visualCode: String
  winner: Float
}

input GameArgs {
  order: GameSortOrder
  skip: Int = 0
  take: Int
  where: [GameWhereInput!]
}

type GamePlayerMembership {
  double: Float
  game(args: GameArgs): Game
  gameId: String!
  gamePlayer(args: PlayerArgs): Player
  id: String!
  mix: Float
  player: Float
  playerId: String!
  single: Float
  systemId: String
  team: Float
}

input GamePlayerMembershipArgs {
  order: GamePlayerMembershipSortOrder
  skip: Int = 0
  take: Int
  where: [GamePlayerMembershipWhereInput!]
}

input GamePlayerMembershipSortOrder {
  double: SortDirection
  game: GameSortOrder
  gamePlayer: PlayerSortOrder
  mix: SortDirection
  player: SortDirection
  single: SortDirection
  team: SortDirection
}

input GamePlayerMembershipWhereInput {
  AND: [GamePlayerMembershipWhereInput!]
  OR: [GamePlayerMembershipWhereInput!]
  game: GameWhereInput
  gameId: StringWhereOperators
  playerId: StringWhereOperators
  systemId: StringWhereOperators
}

input GameSortOrder {
  actualEndTime: SortDirection
  actualStartTime: SortDirection
  courtId: SortDirection
  createdAt: SortDirection
  gameType: SortDirection
  linkId: SortDirection
  linkType: SortDirection
  order: SortDirection
  playedAt: SortDirection
  round: SortDirection
  scheduleSlotId: SortDirection
  scheduledTime: SortDirection
  set1Team1: SortDirection
  set1Team2: SortDirection
  set2Team1: SortDirection
  set2Team2: SortDirection
  set3Team1: SortDirection
  set3Team2: SortDirection
  status: SortDirection
  updatedAt: SortDirection
  visualCode: SortDirection
  winner: SortDirection
}

input GameWhereInput {
  AND: [GameWhereInput!]
  OR: [GameWhereInput!]
  actualEndTime: DateWhereOperators
  actualStartTime: DateWhereOperators
  courtId: StringWhereOperators
  createdAt: DateWhereOperators
  gameType: StringWhereOperators
  linkId: StringWhereOperators
  linkType: StringWhereOperators
  order: NumberWhereOperators
  playedAt: DateWhereOperators
  round: StringWhereOperators
  scheduleSlotId: IdWhereOperators
  scheduledTime: DateWhereOperators
  set1Team1: NumberWhereOperators
  set1Team2: NumberWhereOperators
  set2Team1: NumberWhereOperators
  set2Team2: NumberWhereOperators
  set3Team1: NumberWhereOperators
  set3Team2: NumberWhereOperators
  status: StringWhereOperators
  updatedAt: DateWhereOperators
  winner: NumberWhereOperators
}

input GenerateEntriesFromEnrollmentsInput {
  """If true, regenerate entries even if they already exist"""
  force: Boolean = false

  """Sub-event ID to generate entries for"""
  subEventId: ID!
}

input GuestInfoInput {
  email: String!
  name: String!
  phone: String
}

input IdWhereOperators {
  eq: ID
  in: [ID!]
  isNull: Boolean
  ne: ID
  nin: [ID!]
  raw: ID
}

"""File used for data import"""
type ImportFile {
  createdAt: DateTime!
  errorLog: String
  failedRecords: Float
  filename: String!
  id: ID!
  importType: String!
  mimeType: String!
  originalName: String!
  path: String!
  processedAt: DateTime
  processedRecords: Float
  size: Float!
  status: String!
  successfulRecords: Float
  totalRecords: Float
  updatedAt: DateTime
  uploadedBy: String
}

input ImportFileArgs {
  order: ImportFileSortOrder
  skip: Int = 0
  take: Int
  where: [ImportFileWhereInput!]
}

input ImportFileSortOrder {
  createdAt: SortDirection
  errorLog: SortDirection
  failedRecords: SortDirection
  filename: SortDirection
  importType: SortDirection
  mimeType: SortDirection
  originalName: SortDirection
  path: SortDirection
  processedAt: SortDirection
  processedRecords: SortDirection
  size: SortDirection
  status: SortDirection
  successfulRecords: SortDirection
  totalRecords: SortDirection
  updatedAt: SortDirection
  uploadedBy: SortDirection
}

input ImportFileWhereInput {
  AND: [ImportFileWhereInput!]
  OR: [ImportFileWhereInput!]
  createdAt: DateWhereOperators
  errorLog: StringWhereOperators
  failedRecords: NumberWhereOperators
  filename: StringWhereOperators
  importType: StringWhereOperators
  mimeType: StringWhereOperators
  originalName: StringWhereOperators
  path: StringWhereOperators
  processedAt: DateWhereOperators
  processedRecords: NumberWhereOperators
  size: NumberWhereOperators
  status: StringWhereOperators
  successfulRecords: NumberWhereOperators
  totalRecords: NumberWhereOperators
  updatedAt: DateWhereOperators
  uploadedBy: StringWhereOperators
}

"""Input for indexing data"""
input IndexInput {
  """Select one or more types to index"""
  types: [IndexType!]
}

"""Result of the indexing operation"""
type IndexResult {
  message: String!
}

"""The types of data that can be indexed"""
enum IndexType {
  CLUBS
  COMPETITION_EVENTS
  PLAYERS
  TOURNAMENT_EVENTS
}

"""Information event details"""
type InfoEvent {
  allowCompetition: Boolean
  end: DateTime
  name: String
  start: DateTime
}

"""
The `JSONObject` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSONObject

"""A location where events are held"""
type Location {
  address: String
  city: String
  clubId: String
  coordinates: [Float!]
  courts(args: CourtArgs): [Court!]
  createdAt: DateTime!
  fax: String
  id: ID!
  name: String
  phone: String
  postalcode: String
  state: String
  street: String
  streetNumber: String
  updatedAt: DateTime
}

input LocationArgs {
  order: LocationSortOrder
  skip: Int = 0
  take: Int
  where: [LocationWhereInput!]
}

"""Membership between location and event"""
type LocationEventMembership {
  createdAt: DateTime!
  eventId: String!
  id: ID!
  isActive: Boolean
  isPrimary: Boolean
  locationId: String!
  sortOrder: Float
  updatedAt: DateTime
}

input LocationSortOrder {
  address: SortDirection
  city: SortDirection
  clubId: SortDirection
  coordinates: SortDirection
  createdAt: SortDirection
  fax: SortDirection
  name: SortDirection
  phone: SortDirection
  postalcode: SortDirection
  state: SortDirection
  street: SortDirection
  streetNumber: SortDirection
  updatedAt: SortDirection
}

input LocationWhereInput {
  AND: [LocationWhereInput!]
  OR: [LocationWhereInput!]
  address: StringWhereOperators
  city: StringWhereOperators
  clubId: StringWhereOperators
  coordinates: StringWhereOperators
  createdAt: DateWhereOperators
  fax: StringWhereOperators
  name: StringWhereOperators
  phone: StringWhereOperators
  postalcode: StringWhereOperators
  state: StringWhereOperators
  street: StringWhereOperators
  streetNumber: StringWhereOperators
  updatedAt: DateWhereOperators
}

"""System log entry"""
type LogEntry {
  category: String
  createdAt: DateTime!
  id: ID!
  ipAddress: String
  level: String!
  message: String!
  metadata: String
  method: String
  playerId: String
  requestId: String
  stackTrace: String
  statusCode: Float
  updatedAt: DateTime
  url: String
  userAgent: String
}

input LogEntryArgs {
  order: LogEntrySortOrder
  skip: Int = 0
  take: Int
  where: [LogEntryWhereInput!]
}

input LogEntrySortOrder {
  category: SortDirection
  createdAt: SortDirection
  ipAddress: SortDirection
  level: SortDirection
  message: SortDirection
  metadata: SortDirection
  method: SortDirection
  playerId: SortDirection
  requestId: SortDirection
  stackTrace: SortDirection
  statusCode: SortDirection
  updatedAt: SortDirection
  url: SortDirection
  userAgent: SortDirection
}

input LogEntryWhereInput {
  AND: [LogEntryWhereInput!]
  OR: [LogEntryWhereInput!]
  category: StringWhereOperators
  createdAt: DateWhereOperators
  ipAddress: StringWhereOperators
  level: StringWhereOperators
  message: StringWhereOperators
  metadata: StringWhereOperators
  method: StringWhereOperators
  playerId: StringWhereOperators
  requestId: StringWhereOperators
  stackTrace: StringWhereOperators
  statusCode: NumberWhereOperators
  updatedAt: DateWhereOperators
  url: StringWhereOperators
  userAgent: StringWhereOperators
}

"""Metadata for competition event"""
type MetaEventCompetition {
  amountOfBasePlayers: Int
}

type Mutation {
  addTeamPlayerMembership(membershipType: String! = "REGULAR", playerId: ID!, teamId: ID!): TeamPlayerMembership!
  addToEnrollmentCart(input: AddToCartInput!): EnrollmentSession!

  """Assign multiple entries to a draw"""
  assignEntriesToDraw(input: AssignEntriesToDrawInput!): [Entry!]!

  """Assign an entry to a draw"""
  assignEntryToDraw(input: AssignEntryToDrawInput!): Entry!

  """Auto-seed entries in a draw based on method"""
  autoSeedDraw(input: AutoSeedDrawInput!): [Entry!]!

  """Cancel/withdraw from an enrollment"""
  cancelEnrollment(enrollmentId: ID!): TournamentEnrollment!

  """Clear all seeds from entries in a draw"""
  clearDrawSeeds(drawId: ID!): [Entry!]!
  clearEnrollmentCart(cartId: ID!): Boolean!

  """Create a new tournament draw"""
  createTournamentDraw(input: CreateTournamentDrawInput!): TournamentDraw!

  """Create a new tournament event"""
  createTournamentEvent(data: TournamentEventNewInput!): TournamentEvent!

  """Create a new tournament sub-event"""
  createTournamentSubEvent(data: TournamentSubEventNewInput!): TournamentSubEvent!

  """Delete a tournament draw"""
  deleteTournamentDraw(drawId: ID!): Boolean!

  """Delete a tournament event"""
  deleteTournamentEvent(id: ID!): Boolean!

  """Delete a tournament sub-event"""
  deleteTournamentSubEvent(subEventId: ID!): Boolean!

  """Enroll a guest in a tournament sub-event"""
  enrollGuest(input: EnrollGuestInput!): TournamentEnrollment!
  enrollInSubEvent(notes: String, preferredPartnerId: ID, subEventId: ID!): TournamentEnrollment!

  """Enroll the current player in a tournament sub-event"""
  enrollInTournament(input: EnrollPlayerInput!): TournamentEnrollment!

  """Generate entries from confirmed enrollments for a sub-event"""
  generateEntriesFromEnrollments(input: GenerateEntriesFromEnrollmentsInput!): [Entry!]!
  indexAll(input: IndexInput): IndexResult!

  """Promote a player from the waiting list (organizer only)"""
  promoteFromWaitingList(enrollmentId: ID!): TournamentEnrollment!

  """Remove an entry from its draw"""
  removeEntryFromDraw(input: RemoveEntryFromDrawInput!): Entry!
  removeFromEnrollmentCart(cartId: ID!, subEventIds: [ID!]!): EnrollmentSession!

  """Set the seed for an entry"""
  setEntrySeed(input: SetEntrySeedInput!): Entry!
  submitEnrollmentCart(cartId: ID!): [TournamentEnrollment!]!
  triggerCompetitionSync(eventCode: [String!], forceUpdate: Boolean! = false, includeSubComponents: Boolean! = false, tournamentCode: String): SyncTriggerResponse!
  triggerDiscoverySync(pageSize: Int, refDate: String, searchTerm: String): SyncTriggerResponse!
  triggerDrawSync(drawCode: String!, includeSubComponents: Boolean! = false, tournamentCode: String!): SyncTriggerResponse!
  triggerEventSync(eventCode: String!, includeSubComponents: Boolean! = false, tournamentCode: String!): SyncTriggerResponse!
  triggerGameSync(date: String, drawCode: String, eventCode: String, matchCodes: [String!], tournamentCode: String!): SyncTriggerResponse!
  triggerSubEventSync(eventCode: String!, includeSubComponents: Boolean! = false, subEventCode: String, tournamentCode: String!): SyncTriggerResponse!
  triggerTeamMatching(eventCode: String, tournamentCode: String!, unmatchedTeams: [UnmatchedTeamInput!]): SyncTriggerResponse!
  triggerTournamentSync(eventCode: [String!], forceUpdate: Boolean! = false, includeSubComponents: Boolean! = false, tournamentCode: String): SyncTriggerResponse!

  """Update an enrollment"""
  updateEnrollment(enrollmentId: ID!, input: UpdateEnrollmentInput!): TournamentEnrollment!
  updatePlayer(input: PlayerUpdateInput!, playerId: ID!): Player!
  updatePlayerClaims(claimIds: [ID!]!, playerId: ID!): Player!
  updateTeam(input: TeamUpdateInput!, teamId: ID!): Team!
  updateTeamPlayerMembership(id: ID!, membershipType: String!): TeamPlayerMembership!

  """Update a tournament draw"""
  updateTournamentDraw(drawId: ID!, input: UpdateTournamentDrawInput!): TournamentDraw!

  """Update a tournament event"""
  updateTournamentEvent(data: TournamentEventUpdateInput!, id: ID!): TournamentEvent!

  """Update tournament phase"""
  updateTournamentPhase(id: ID!, phase: TournamentPhase!): TournamentEvent!

  """Update a tournament sub-event"""
  updateTournamentSubEvent(data: TournamentSubEventUpdateInput!, subEventId: ID!): TournamentSubEvent!
}

"""User notification"""
type Notification {
  createdAt: DateTime!
  id: ID!
  linkId: String!
  linkType: String!
  meta: String
  read: Boolean!
  sendToId: String!
  type: String!
  updatedAt: DateTime
}

input NotificationArgs {
  order: NotificationSortOrder
  skip: Int = 0
  take: Int
  where: [NotificationWhereInput!]
}

input NotificationSortOrder {
  createdAt: SortDirection
  linkId: SortDirection
  linkType: SortDirection
  meta: SortDirection
  read: SortDirection
  sendToId: SortDirection
  type: SortDirection
  updatedAt: SortDirection
}

input NotificationWhereInput {
  AND: [NotificationWhereInput!]
  OR: [NotificationWhereInput!]
  createdAt: DateWhereOperators
  linkId: StringWhereOperators
  linkType: StringWhereOperators
  meta: StringWhereOperators
  read: BooleanWhereOperators
  sendToId: StringWhereOperators
  type: StringWhereOperators
  updatedAt: DateWhereOperators
}

input NumberWhereOperators {
  between: [Float!]
  eq: Float
  gt: Float
  gte: Float
  in: [Float!]
  isNull: Boolean
  lt: Float
  lte: Float
  ne: Float
  nin: [Float!]
  raw: String
}

"""A Player"""
type Player {
  birthDate: DateTime
  claims(args: ClaimArgs): [Claim!]
  clubPlayerMemberships(args: ClubPlayerMembershipArgs): [ClubPlayerMembership!]
  competitionPlayer: Boolean
  createdAt: DateTime!
  email: String
  firstName: String
  fullName: String!
  gamePlayerMemberships(args: GamePlayerMembershipArgs): [GamePlayerMembership!]
  gender: String
  id: ID!
  lastName: String
  memberId: String
  permissions: [String!]
  phone: String
  rankingLastPlaces(args: RankingLastPlaceArgs): [RankingLastPlace!]
  rankingPlaces: [RankingPlace!]
  rankingPoints: [RankingPoint!]
  roles: [Role!]
  slug: String
  sub: String
  teamPlayerMemberships(args: TeamPlayerMembershipArgs): [TeamPlayerMembership!]
  updatedAt: DateTime
}

input PlayerArgs {
  order: PlayerSortOrder
  skip: Int = 0
  take: Int
  where: [PlayerWhereInput!]
}

input PlayerSortOrder {
  birthDate: SortDirection
  competitionPlayer: SortDirection
  createdAt: SortDirection
  email: SortDirection
  firstName: SortDirection
  fullName: SortDirection
  gender: SortDirection
  lastName: SortDirection
  memberId: SortDirection
  phone: SortDirection
  slug: SortDirection
  updatedAt: SortDirection
}

input PlayerUpdateInput {
  birthDate: DateTime
  competitionPlayer: Boolean
  email: String
  firstName: String
  fullName: String
  gender: String
  id: ID
  lastName: String
  memberId: String
  phone: String
  slug: String
  sub: String
}

input PlayerWhereInput {
  AND: [PlayerWhereInput!]
  OR: [PlayerWhereInput!]
  birthDate: DateWhereOperators
  competitionPlayer: BooleanWhereOperators
  createdAt: DateWhereOperators
  email: StringWhereOperators
  firstName: StringWhereOperators
  gender: StringWhereOperators
  lastName: StringWhereOperators
  memberId: StringWhereOperators
  slug: StringWhereOperators
  sub: StringWhereOperators
  updatedAt: DateWhereOperators
}

type Query {
  availabilities(args: AvailabilityArgs): [Availability!]!
  availability(id: ID!): Availability!
  claim(id: ID!): Claim!
  claims(args: ClaimArgs): [Claim!]!
  club(id: ID!): Club!
  clubs(args: ClubArgs): [Club!]!
  comment(id: ID!): Comment!
  comments(args: CommentArgs): [Comment!]!
  competitionAssemblies: [CompetitionAssembly!]!
  competitionAssembly(id: ID!): CompetitionAssembly!
  competitionDraw(id: ID!): CompetitionDraw!
  competitionDraws(args: CompetitionDrawArgs): [CompetitionDraw!]!
  competitionEncounter(id: ID!): CompetitionEncounter!
  competitionEncounterChange(id: ID!): CompetitionEncounterChange!
  competitionEncounterChangeDate(id: ID!): CompetitionEncounterChangeDate!
  competitionEncounterChangeDates: [CompetitionEncounterChangeDate!]!
  competitionEncounterChanges: [CompetitionEncounterChange!]!
  competitionEncounters(args: CompetitionEncounterArgs): [CompetitionEncounter!]!
  competitionEvent(id: ID!): CompetitionEvent!
  competitionEvents(args: CompetitionEventArgs): [CompetitionEvent!]!
  competitionGroupSubEventMembership(id: ID!): CompetitionGroupSubEventMembership!
  competitionGroupSubEventMemberships: [CompetitionGroupSubEventMembership!]!
  competitionSubEvent(id: ID!): CompetitionSubEvent!
  competitionSubEvents(args: CompetitionSubEventArgs): [CompetitionSubEvent!]!
  court(id: ID!): Court!
  courts(args: CourtArgs): [Court!]!
  cronJob(id: ID!): CronJob!
  cronJobs(args: CronJobArgs): [CronJob!]!
  enrollmentSession(args: EnrollmentSessionArgs): EnrollmentSession
  enrollmentSessions(args: EnrollmentSessionArgs): [EnrollmentSession!]!
  entries(args: EntryArgs): [Entry!]!
  entry(id: ID!): Entry!
  faq(id: ID!): Faq!
  faqs(args: FaqArgs): [Faq!]!
  game(id: ID!): Game!
  games(args: GameArgs): [Game!]!
  groupSubeventMembership(id: ID!): TournamentGroupSubEventMembership!
  groupSubeventMemberships: [TournamentGroupSubEventMembership!]!
  importFile(id: ID!): ImportFile!
  importFiles(args: ImportFileArgs): [ImportFile!]!
  location(id: ID!): Location!
  locationEventMembership(id: ID!): LocationEventMembership!
  locationEventMemberships: [LocationEventMembership!]!
  locations(args: LocationArgs): [Location!]!
  logEntries(args: LogEntryArgs): [LogEntry!]!
  logEntry(id: ID!): LogEntry!

  """Get players looking for a partner in a sub-event"""
  lookingForPartner(subEventId: ID!): [TournamentEnrollment!]!
  me: Player

  """Get current user enrollments for a tournament"""
  myTournamentEnrollments(tournamentEventId: ID!): [TournamentEnrollment!]!
  notification(id: ID!): Notification!
  notifications(args: NotificationArgs): [Notification!]!
  player(id: ID!): Player!
  players(args: PlayerArgs): [Player!]!
  rankingGroup(id: ID!): RankingGroup!
  rankingGroups: [RankingGroup!]!
  rankingLastPlace(id: ID!): RankingLastPlace!
  rankingLastPlaces(playerId: ID, systemId: ID): [RankingLastPlace!]!
  rankingPlace(id: ID!): RankingPlace!
  rankingPlaces(playerId: ID, systemId: ID): [RankingPlace!]!
  rankingPoint(id: ID!): RankingPoint!
  rankingPoints(gameId: ID, playerId: ID, systemId: ID): [RankingPoint!]!
  rankingSystem(id: ID): RankingSystem!
  rankingSystems(args: RankingSystemArgs): [RankingSystem!]!
  requestLink(id: ID!): RequestLink!
  requestLinks(args: RequestLinkArgs): [RequestLink!]!
  rule(id: ID!): Rule!
  rules(args: RuleArgs): [Rule!]!
  search: Player
  service(id: ID!): Service!
  services(args: ServiceArgs): [Service!]!
  setting(id: ID!): Setting!
  settings(args: SettingArgs): [Setting!]!
  standing(id: ID!): Standing!
  standings(args: StandingArgs): [Standing!]!

  """Get enrollments for a specific sub-event"""
  subEventEnrollments(status: EnrollmentStatus, subEventId: ID!): [TournamentEnrollment!]!
  syncJobs(limit: Int, status: String): [SyncJob!]!
  syncQueueStatsByName: String!
  syncStatus: SyncStatus!
  team(id: ID!): Team!
  teams(args: TeamArgs): [Team!]!
  tournamentDraw(id: ID!): TournamentDraw!
  tournamentDraws(args: TournamentDrawArgs): [TournamentDraw!]!
  tournamentEnrollment(id: ID!): TournamentEnrollment!
  tournamentEnrollments(args: TournamentEnrollmentArgs): [TournamentEnrollment!]!
  tournamentEvent(id: ID!): TournamentEvent!
  tournamentEvents(args: TournamentEventArgs): [TournamentEvent!]!
  tournamentSubEvent(id: ID!): TournamentSubEvent!
  tournamentSubEvents(args: TournamentSubEventArgs): [TournamentSubEvent!]!

  """Get waiting list for a sub-event"""
  waitingList(subEventId: ID!): [TournamentEnrollment!]!
}

type QueueStats {
  active: Int!
  completed: Int!
  failed: Int!
  waiting: Int!
}

"""A RankingGroup"""
type RankingGroup {
  createdAt: DateTime!
  id: ID!
  name: String!
  updatedAt: DateTime
}

"""A RankingLastPlace"""
type RankingLastPlace {
  createdAt: DateTime!
  double: Float
  doubleInactive: Boolean!
  doublePoints: Float
  doublePointsDowngrade: Float
  doubleRank: Float
  gender: String
  group: RankingGroup
  groupId: String
  id: ID!
  mix: Float
  mixInactive: Boolean!
  mixPoints: Float
  mixPointsDowngrade: Float
  mixRank: Float
  player: Player
  playerId: String!
  rankingDate: DateTime!
  single: Float
  singleInactive: Boolean!
  singlePoints: Float
  singlePointsDowngrade: Float
  singleRank: Float
  system: RankingSystem
  systemId: String!
  totalDoubleRanking: Float
  totalMixRanking: Float
  totalSingleRanking: Float
  totalWithinDoubleLevel: Float
  totalWithinMixLevel: Float
  totalWithinSingleLevel: Float
  updatedAt: DateTime
}

input RankingLastPlaceArgs {
  order: RankingLastPlaceSortOrder
  skip: Int = 0
  take: Int
  where: [RankingLastPlaceWhereInput!]
}

input RankingLastPlaceSortOrder {
  createdAt: SortDirection
  double: SortDirection
  doubleInactive: SortDirection
  doublePoints: SortDirection
  doublePointsDowngrade: SortDirection
  doubleRank: SortDirection
  gender: SortDirection
  mix: SortDirection
  mixInactive: SortDirection
  mixPoints: SortDirection
  mixPointsDowngrade: SortDirection
  mixRank: SortDirection
  rankingDate: SortDirection
  single: SortDirection
  singleInactive: SortDirection
  singlePoints: SortDirection
  singlePointsDowngrade: SortDirection
  singleRank: SortDirection
  totalDoubleRanking: SortDirection
  totalMixRanking: SortDirection
  totalSingleRanking: SortDirection
  totalWithinDoubleLevel: SortDirection
  totalWithinMixLevel: SortDirection
  totalWithinSingleLevel: SortDirection
  updatedAt: SortDirection
}

input RankingLastPlaceWhereInput {
  AND: [RankingLastPlaceWhereInput!]
  OR: [RankingLastPlaceWhereInput!]
  createdAt: DateWhereOperators
  double: NumberWhereOperators
  doubleInactive: BooleanWhereOperators
  doublePoints: NumberWhereOperators
  doublePointsDowngrade: NumberWhereOperators
  doubleRank: NumberWhereOperators
  gender: StringWhereOperators
  groupId: StringWhereOperators
  mix: NumberWhereOperators
  mixInactive: BooleanWhereOperators
  mixPoints: NumberWhereOperators
  mixPointsDowngrade: NumberWhereOperators
  mixRank: NumberWhereOperators
  playerId: StringWhereOperators
  rankingDate: DateWhereOperators
  single: NumberWhereOperators
  singleInactive: BooleanWhereOperators
  singlePoints: NumberWhereOperators
  singlePointsDowngrade: NumberWhereOperators
  singleRank: NumberWhereOperators
  systemId: StringWhereOperators
  totalDoubleRanking: NumberWhereOperators
  totalMixRanking: NumberWhereOperators
  totalSingleRanking: NumberWhereOperators
  totalWithinDoubleLevel: NumberWhereOperators
  totalWithinMixLevel: NumberWhereOperators
  totalWithinSingleLevel: NumberWhereOperators
  updatedAt: DateWhereOperators
}

"""A RankingPlace"""
type RankingPlace {
  createdAt: DateTime!
  double: Float
  doubleInactive: Boolean!
  doublePoints: Float
  doublePointsDowngrade: Float
  doubleRank: Float
  gender: String
  group: RankingGroup
  groupId: ID
  id: ID!
  mix: Float
  mixInactive: Boolean!
  mixPoints: Float
  mixPointsDowngrade: Float
  mixRank: Float
  player: Player
  playerId: ID!
  rankingDate: DateTime!
  single: Float
  singleInactive: Boolean!
  singlePoints: Float
  singlePointsDowngrade: Float
  singleRank: Float
  system: RankingSystem
  systemId: ID!
  totalDoubleRanking: Float
  totalMixRanking: Float
  totalSingleRanking: Float
  totalWithinDoubleLevel: Float
  totalWithinMixLevel: Float
  totalWithinSingleLevel: Float
  updatePossible: Boolean!
  updatedAt: DateTime
}

input RankingPlaceArgs {
  order: RankingPlaceSortOrder
  skip: Int = 0
  take: Int
  where: [RankingPlaceWhereInput!]
}

input RankingPlaceSortOrder {
  createdAt: SortDirection
  double: SortDirection
  doubleInactive: SortDirection
  doublePoints: SortDirection
  doublePointsDowngrade: SortDirection
  doubleRank: SortDirection
  gender: SortDirection
  mix: SortDirection
  mixInactive: SortDirection
  mixPoints: SortDirection
  mixPointsDowngrade: SortDirection
  mixRank: SortDirection
  rankingDate: SortDirection
  single: SortDirection
  singleInactive: SortDirection
  singlePoints: SortDirection
  singlePointsDowngrade: SortDirection
  singleRank: SortDirection
  totalDoubleRanking: SortDirection
  totalMixRanking: SortDirection
  totalSingleRanking: SortDirection
  totalWithinDoubleLevel: SortDirection
  totalWithinMixLevel: SortDirection
  totalWithinSingleLevel: SortDirection
  updatePossible: SortDirection
  updatedAt: SortDirection
}

input RankingPlaceWhereInput {
  AND: [RankingPlaceWhereInput!]
  OR: [RankingPlaceWhereInput!]
  createdAt: DateWhereOperators
  double: NumberWhereOperators
  doubleInactive: BooleanWhereOperators
  doublePoints: NumberWhereOperators
  doublePointsDowngrade: NumberWhereOperators
  doubleRank: NumberWhereOperators
  gender: StringWhereOperators
  mix: NumberWhereOperators
  mixInactive: BooleanWhereOperators
  mixPoints: NumberWhereOperators
  mixPointsDowngrade: NumberWhereOperators
  mixRank: NumberWhereOperators
  rankingDate: DateWhereOperators
  single: NumberWhereOperators
  singleInactive: BooleanWhereOperators
  singlePoints: NumberWhereOperators
  singlePointsDowngrade: NumberWhereOperators
  singleRank: NumberWhereOperators
  totalDoubleRanking: NumberWhereOperators
  totalMixRanking: NumberWhereOperators
  totalSingleRanking: NumberWhereOperators
  totalWithinDoubleLevel: NumberWhereOperators
  totalWithinMixLevel: NumberWhereOperators
  totalWithinSingleLevel: NumberWhereOperators
  updatePossible: BooleanWhereOperators
  updatedAt: DateWhereOperators
}

"""A RankingPoint"""
type RankingPoint {
  createdAt: DateTime!
  differenceInLevel: Float
  game: Game
  gameId: ID!
  id: ID!
  player: Player
  playerId: ID!
  points: Float
  rankingDate: DateTime
  system: RankingSystem
  systemId: ID!
  updatedAt: DateTime
}

input RankingPointArgs {
  order: RankingPointSortOrder
  skip: Int = 0
  take: Int
  where: [RankingPointWhereInput!]
}

input RankingPointSortOrder {
  createdAt: SortDirection
  differenceInLevel: SortDirection
  points: SortDirection
  rankingDate: SortDirection
  updatedAt: SortDirection
}

input RankingPointWhereInput {
  AND: [RankingPointWhereInput!]
  OR: [RankingPointWhereInput!]
  createdAt: DateWhereOperators
  differenceInLevel: NumberWhereOperators
  points: NumberWhereOperators
  rankingDate: DateWhereOperators
  updatedAt: DateWhereOperators
}

"""A RankingSystem"""
type RankingSystem {
  amountOfLevels: Float
  calculateUpdates: Boolean
  calculationDayOfWeek: Float
  calculationIntervalAmount: Float
  calculationIntervalUnit: String
  calculationLastUpdate: DateTime
  createdAt: DateTime!
  differenceForDowngradeDouble: Float
  differenceForDowngradeMix: Float
  differenceForDowngradeSingle: Float
  differenceForUpgradeDouble: Float
  differenceForUpgradeMix: Float
  differenceForUpgradeSingle: Float
  gamesForInactivty: Float
  id: ID!
  inactiveBehavior: String
  inactivityAmount: Float
  inactivityUnit: String
  latestXGamesToUse: Float
  levelArray: [Int!]
  levelArrayOneMinus: [Int!]
  maxDiffLevels: Float
  maxDiffLevelsHighest: Float
  maxLevelDownPerChange: Float
  maxLevelUpPerChange: Float
  minNumberOfGamesUsedForDowngrade: Float
  minNumberOfGamesUsedForUpgrade: Float
  name: String!
  periodAmount: Float
  periodUnit: String
  pointsToGoDown: [Int!]
  pointsToGoUp: [Int!]
  pointsWhenWinningAgainst: [Int!]
  primary: Boolean!
  procentLosing: Float
  procentWinning: Float
  procentWinningPlus1: Float
  rankingLastPlaces(args: RankingLastPlaceArgs): [RankingLastPlace!]!
  rankingPlaces(args: RankingPlaceArgs): [RankingPlace!]!
  rankingPoints(args: RankingPointArgs): [RankingPoint!]!
  rankingSystem: String
  runCurrently: Boolean!
  startingType: String!
  updateDayOfWeek: Float
  updateIntervalAmount: Float
  updateIntervalUnit: String
  updateLastUpdate: DateTime
  updatedAt: DateTime!
}

input RankingSystemArgs {
  order: RankingSystemSortOrder
  skip: Int = 0
  take: Int
  where: [RankingSystemWhereInput!]
}

input RankingSystemSortOrder {
  amountOfLevels: SortDirection
  calculateUpdates: SortDirection
  calculationDayOfWeek: SortDirection
  calculationIntervalAmount: SortDirection
  calculationIntervalUnit: SortDirection
  calculationLastUpdate: SortDirection
  createdAt: SortDirection
  differenceForDowngradeDouble: SortDirection
  differenceForDowngradeMix: SortDirection
  differenceForDowngradeSingle: SortDirection
  differenceForUpgradeDouble: SortDirection
  differenceForUpgradeMix: SortDirection
  differenceForUpgradeSingle: SortDirection
  gamesForInactivty: SortDirection
  inactiveBehavior: SortDirection
  inactivityAmount: SortDirection
  inactivityUnit: SortDirection
  latestXGamesToUse: SortDirection
  levelArray: SortDirection
  levelArrayOneMinus: SortDirection
  maxDiffLevels: SortDirection
  maxDiffLevelsHighest: SortDirection
  maxLevelDownPerChange: SortDirection
  maxLevelUpPerChange: SortDirection
  minNumberOfGamesUsedForDowngrade: SortDirection
  minNumberOfGamesUsedForUpgrade: SortDirection
  name: SortDirection
  periodAmount: SortDirection
  periodUnit: SortDirection
  pointsToGoDown: SortDirection
  pointsToGoUp: SortDirection
  pointsWhenWinningAgainst: SortDirection
  primary: SortDirection
  procentLosing: SortDirection
  procentWinning: SortDirection
  procentWinningPlus1: SortDirection
  rankingSystem: SortDirection
  runCurrently: SortDirection
  startingType: SortDirection
  updateDayOfWeek: SortDirection
  updateIntervalAmount: SortDirection
  updateIntervalUnit: SortDirection
  updateLastUpdate: SortDirection
  updatedAt: SortDirection
}

input RankingSystemWhereInput {
  AND: [RankingSystemWhereInput!]
  OR: [RankingSystemWhereInput!]
  amountOfLevels: NumberWhereOperators
  calculateUpdates: BooleanWhereOperators
  calculationDayOfWeek: NumberWhereOperators
  calculationIntervalAmount: NumberWhereOperators
  calculationIntervalUnit: StringWhereOperators
  calculationLastUpdate: DateWhereOperators
  createdAt: DateWhereOperators
  differenceForDowngradeDouble: NumberWhereOperators
  differenceForDowngradeMix: NumberWhereOperators
  differenceForDowngradeSingle: NumberWhereOperators
  differenceForUpgradeDouble: NumberWhereOperators
  differenceForUpgradeMix: NumberWhereOperators
  differenceForUpgradeSingle: NumberWhereOperators
  gamesForInactivty: NumberWhereOperators
  inactiveBehavior: StringWhereOperators
  inactivityAmount: NumberWhereOperators
  inactivityUnit: StringWhereOperators
  latestXGamesToUse: NumberWhereOperators
  maxDiffLevels: NumberWhereOperators
  maxDiffLevelsHighest: NumberWhereOperators
  maxLevelDownPerChange: NumberWhereOperators
  maxLevelUpPerChange: NumberWhereOperators
  minNumberOfGamesUsedForDowngrade: NumberWhereOperators
  minNumberOfGamesUsedForUpgrade: NumberWhereOperators
  name: StringWhereOperators
  periodAmount: NumberWhereOperators
  periodUnit: StringWhereOperators
  primary: BooleanWhereOperators
  procentLosing: NumberWhereOperators
  procentWinning: NumberWhereOperators
  procentWinningPlus1: NumberWhereOperators
  rankingSystem: StringWhereOperators
  runCurrently: BooleanWhereOperators
  startingType: StringWhereOperators
  updateDayOfWeek: NumberWhereOperators
  updateIntervalAmount: NumberWhereOperators
  updateIntervalUnit: StringWhereOperators
  updateLastUpdate: DateWhereOperators
  updatedAt: DateWhereOperators
}

input RemoveEntryFromDrawInput {
  """Entry ID to remove from draw"""
  entryId: ID!
}

"""A request link for password reset or email verification"""
type RequestLink {
  createdAt: DateTime!
  expiresAt: DateTime!
  id: ID!
  isUsed: Boolean
  playerId: String!
  requestId: String!
  requestType: String!
  sub: String!
  updatedAt: DateTime
  usedAt: DateTime
}

input RequestLinkArgs {
  order: RequestLinkSortOrder
  skip: Int = 0
  take: Int
  where: [RequestLinkWhereInput!]
}

input RequestLinkSortOrder {
  createdAt: SortDirection
  expiresAt: SortDirection
  isUsed: SortDirection
  playerId: SortDirection
  requestId: SortDirection
  requestType: SortDirection
  sub: SortDirection
  updatedAt: SortDirection
  usedAt: SortDirection
}

input RequestLinkWhereInput {
  AND: [RequestLinkWhereInput!]
  OR: [RequestLinkWhereInput!]
  createdAt: DateWhereOperators
  expiresAt: DateWhereOperators
  isUsed: BooleanWhereOperators
  playerId: StringWhereOperators
  requestId: StringWhereOperators
  requestType: StringWhereOperators
  sub: StringWhereOperators
  updatedAt: DateWhereOperators
  usedAt: DateWhereOperators
}

"""A Role"""
type Role {
  claims: [Claim!]
  club: Club
  clubId: ID
  competition: CompetitionEvent
  competitionId: ID
  createdAt: DateTime
  description: String
  id: ID!
  linkId: ID
  linkType: String
  locked: Boolean!
  name: String
  players: [Player!]
  team: Team
  teamId: ID
  tournament: TournamentEvent
  tournamentId: ID
  updatedAt: DateTime
}

"""Business rule configuration"""
type Rule {
  actions: String
  conditions: String
  createdAt: DateTime!
  createdBy: String
  description: String
  id: ID!
  isActive: Boolean!
  lastModifiedBy: String
  name: String!
  priority: Float
  ruleType: String!
  scope: String!
  updatedAt: DateTime
  validFrom: DateTime
  validTo: DateTime
}

input RuleArgs {
  order: RuleSortOrder
  skip: Int = 0
  take: Int
  where: [RuleWhereInput!]
}

input RuleSortOrder {
  actions: SortDirection
  conditions: SortDirection
  createdAt: SortDirection
  createdBy: SortDirection
  description: SortDirection
  isActive: SortDirection
  lastModifiedBy: SortDirection
  name: SortDirection
  priority: SortDirection
  ruleType: SortDirection
  scope: SortDirection
  updatedAt: SortDirection
  validFrom: SortDirection
  validTo: SortDirection
}

input RuleWhereInput {
  AND: [RuleWhereInput!]
  OR: [RuleWhereInput!]
  actions: StringWhereOperators
  conditions: StringWhereOperators
  createdAt: DateWhereOperators
  createdBy: StringWhereOperators
  description: StringWhereOperators
  isActive: BooleanWhereOperators
  lastModifiedBy: StringWhereOperators
  name: StringWhereOperators
  priority: NumberWhereOperators
  ruleType: StringWhereOperators
  scope: StringWhereOperators
  updatedAt: DateWhereOperators
  validFrom: DateWhereOperators
  validTo: DateWhereOperators
}

type ScheduleConflict {
  conflictingGameIds: [ID!]!
  gameId: ID!
  message: String!
  playerId: ID!
  playerName: String!
}

"""Method for seeding entries in a draw"""
enum SeedingMethod {
  BY_RANKING
  MANUAL
  RANDOM
}

"""External service configuration"""
type Service {
  authentication: String
  configuration: String
  createdAt: DateTime!
  description: String
  endpoint: String
  healthStatus: String
  id: ID!
  isActive: Boolean!
  lastError: String
  lastHealthCheck: DateTime
  maxRetries: Float
  name: String!
  serviceType: String!
  timeoutMs: Float
  updatedAt: DateTime
}

input ServiceArgs {
  order: ServiceSortOrder
  skip: Int = 0
  take: Int
  where: [ServiceWhereInput!]
}

input ServiceSortOrder {
  authentication: SortDirection
  configuration: SortDirection
  createdAt: SortDirection
  description: SortDirection
  endpoint: SortDirection
  healthStatus: SortDirection
  isActive: SortDirection
  lastError: SortDirection
  lastHealthCheck: SortDirection
  maxRetries: SortDirection
  name: SortDirection
  serviceType: SortDirection
  timeoutMs: SortDirection
  updatedAt: SortDirection
}

input ServiceWhereInput {
  AND: [ServiceWhereInput!]
  OR: [ServiceWhereInput!]
  authentication: StringWhereOperators
  configuration: StringWhereOperators
  createdAt: DateWhereOperators
  description: StringWhereOperators
  endpoint: StringWhereOperators
  healthStatus: StringWhereOperators
  isActive: BooleanWhereOperators
  lastError: StringWhereOperators
  lastHealthCheck: DateWhereOperators
  maxRetries: NumberWhereOperators
  name: StringWhereOperators
  serviceType: StringWhereOperators
  timeoutMs: NumberWhereOperators
  updatedAt: DateWhereOperators
}

input SetEntrySeedInput {
  """Entry ID to set seed for"""
  entryId: ID!

  """Seed position (1 = top seed)"""
  seed: Int!
}

"""User notification and preference settings"""
type Setting {
  clubEnrollmentNotification: Int!
  createdAt: DateTime!
  encounterChangeConfirmationNotification: Int!
  encounterChangeFinishedNotification: Int!
  encounterChangeNewNotification: Int!
  encounterHasCommentNotification: Int!
  encounterNotAcceptedNotification: Int!
  encounterNotEnteredNotification: Int!
  id: ID!
  language: String
  playerId: String!
  pushSubscriptions: String
  synEncounterFailed: Int!
  syncFailedNotification: Int!
  syncSuccessNotification: Int!
  updatedAt: DateTime
}

input SettingArgs {
  order: SettingSortOrder
  skip: Int = 0
  take: Int
  where: [SettingWhereInput!]
}

input SettingSortOrder {
  clubEnrollmentNotification: SortDirection
  createdAt: SortDirection
  encounterChangeConfirmationNotification: SortDirection
  encounterChangeFinishedNotification: SortDirection
  encounterChangeNewNotification: SortDirection
  encounterHasCommentNotification: SortDirection
  encounterNotAcceptedNotification: SortDirection
  encounterNotEnteredNotification: SortDirection
  language: SortDirection
  playerId: SortDirection
  pushSubscriptions: SortDirection
  synEncounterFailed: SortDirection
  syncFailedNotification: SortDirection
  syncSuccessNotification: SortDirection
  updatedAt: SortDirection
}

input SettingWhereInput {
  AND: [SettingWhereInput!]
  OR: [SettingWhereInput!]
  clubEnrollmentNotification: NumberWhereOperators
  createdAt: DateWhereOperators
  encounterChangeConfirmationNotification: NumberWhereOperators
  encounterChangeFinishedNotification: NumberWhereOperators
  encounterChangeNewNotification: NumberWhereOperators
  encounterHasCommentNotification: NumberWhereOperators
  encounterNotAcceptedNotification: NumberWhereOperators
  encounterNotEnteredNotification: NumberWhereOperators
  language: StringWhereOperators
  playerId: StringWhereOperators
  pushSubscriptions: StringWhereOperators
  synEncounterFailed: NumberWhereOperators
  syncFailedNotification: NumberWhereOperators
  syncSuccessNotification: NumberWhereOperators
  updatedAt: DateWhereOperators
}

enum SortDirection {
  ASC
  DESC
}

"""Standing position in a competition"""
type Standing {
  createdAt: DateTime!
  entry: Entry
  entryId: ID
  faller: Boolean
  gamesLost: Float
  gamesWon: Float
  id: ID!
  lost: Float
  played: Float
  points: Float
  position: Float!
  riser: Boolean
  setsLost: Float
  setsWon: Float
  size: Float
  tied: Float
  totalPointsLost: Float
  totalPointsWon: Float
  updatedAt: DateTime
  won: Float
}

input StandingArgs {
  order: StandingSortOrder
  skip: Int = 0
  take: Int
  where: [StandingWhereInput!]
}

input StandingSortOrder {
  createdAt: SortDirection
  entryId: SortDirection
  faller: SortDirection
  gamesLost: SortDirection
  gamesWon: SortDirection
  lost: SortDirection
  played: SortDirection
  points: SortDirection
  position: SortDirection
  riser: SortDirection
  setsLost: SortDirection
  setsWon: SortDirection
  size: SortDirection
  tied: SortDirection
  totalPointsLost: SortDirection
  totalPointsWon: SortDirection
  updatedAt: SortDirection
  won: SortDirection
}

input StandingWhereInput {
  AND: [StandingWhereInput!]
  OR: [StandingWhereInput!]
  createdAt: DateWhereOperators
  entryId: IdWhereOperators
  faller: BooleanWhereOperators
  gamesLost: NumberWhereOperators
  gamesWon: NumberWhereOperators
  lost: NumberWhereOperators
  played: NumberWhereOperators
  points: NumberWhereOperators
  position: NumberWhereOperators
  riser: BooleanWhereOperators
  setsLost: NumberWhereOperators
  setsWon: NumberWhereOperators
  size: NumberWhereOperators
  tied: NumberWhereOperators
  totalPointsLost: NumberWhereOperators
  totalPointsWon: NumberWhereOperators
  updatedAt: DateWhereOperators
  won: NumberWhereOperators
}

input StringWhereOperators {
  eq: String
  ilike: String
  in: [String!]
  isNull: Boolean
  like: String
  ne: String
  nin: [String!]
  raw: String
}

type SyncJob {
  data: String!
  failedReason: String
  finishedOn: DateTime
  id: String!
  name: String!
  parentId: String
  processedOn: DateTime
  progress: Int!
  status: String!
  timestamp: Float
}

type SyncStatus {
  queues: QueueStats!
  status: String!
  timestamp: String!
}

type SyncTriggerResponse {
  message: String!
  success: Boolean!
}

"""A Team"""
type Team {
  abbreviation: String
  captain: Player
  captainId: String
  club: Club
  clubId: String
  createdAt: DateTime!
  email: String
  entries: Entry
  id: ID!
  link: String!
  name: String
  phone: String
  preferredDay: String
  preferredDay2: String
  preferredTime: String
  preferredTime2: String
  prefferedLocation2Id: String
  prefferedLocationId: String
  season: Float!
  slug: String
  teamNumber: Float
  teamPlayerMemberships(args: TeamPlayerMembershipArgs): [TeamPlayerMembership!]
  type: String
  updatedAt: DateTime
}

input TeamArgs {
  order: TeamSortOrder
  skip: Int = 0
  take: Int
  where: [TeamWhereInput!]
}

"""A TeamPlayerMembership"""
type TeamPlayerMembership {
  createdAt: DateTime!
  end: DateTime!
  id: String!
  membershipType: String!
  player(args: PlayerArgs): Player
  playerId: String!
  start: DateTime!
  team(args: TeamArgs): Team
  teamId: String!
  updatedAt: DateTime
}

input TeamPlayerMembershipArgs {
  order: TeamPlayerMembershipSortOrder
  skip: Int = 0
  take: Int
  where: [TeamPlayerMembershipWhereInput!]
}

input TeamPlayerMembershipSortOrder {
  createdAt: SortDirection
  end: SortDirection
  membershipType: SortDirection
  player: PlayerSortOrder
  playerId: SortDirection
  start: SortDirection
  team: TeamSortOrder
  teamId: SortDirection
  updatedAt: SortDirection
}

input TeamPlayerMembershipWhereInput {
  AND: [TeamPlayerMembershipWhereInput!]
  OR: [TeamPlayerMembershipWhereInput!]
  createdAt: DateWhereOperators
  end: DateWhereOperators
  membershipType: StringWhereOperators
  playerId: StringWhereOperators
  start: DateWhereOperators
  teamId: StringWhereOperators
  updatedAt: DateWhereOperators
}

input TeamSortOrder {
  abbreviation: SortDirection
  captain: SortDirection
  captainId: SortDirection
  club: SortDirection
  clubId: SortDirection
  createdAt: SortDirection
  email: SortDirection
  entries: SortDirection
  link: SortDirection
  name: SortDirection
  phone: SortDirection
  preferredDay: SortDirection
  preferredDay2: SortDirection
  preferredTime: SortDirection
  preferredTime2: SortDirection
  prefferedLocation2Id: SortDirection
  prefferedLocationId: SortDirection
  season: SortDirection
  slug: SortDirection
  teamNumber: SortDirection
  teamPlayerMemberships: SortDirection
  type: SortDirection
  updatedAt: SortDirection
}

input TeamUpdateInput {
  abbreviation: String
  captainId: String
  clubId: String
  email: String
  id: ID
  link: String
  name: String
  phone: String
  preferredDay: String
  preferredDay2: String
  preferredTime: String
  preferredTime2: String
  prefferedLocation2Id: String
  prefferedLocationId: String
  season: Float
  slug: String
  teamNumber: Float
  type: String
}

input TeamWhereInput {
  AND: [TeamWhereInput!]
  OR: [TeamWhereInput!]
  captainId: StringWhereOperators
  clubId: StringWhereOperators
  createdAt: DateWhereOperators
  email: StringWhereOperators
  id: IdWhereOperators
  link: StringWhereOperators
  name: StringWhereOperators
  phone: StringWhereOperators
  preferredDay: StringWhereOperators
  preferredDay2: StringWhereOperators
  preferredTime: StringWhereOperators
  preferredTime2: StringWhereOperators
  prefferedLocation2Id: StringWhereOperators
  prefferedLocationId: StringWhereOperators
  season: NumberWhereOperators
  slug: StringWhereOperators
  teamNumber: NumberWhereOperators
  type: StringWhereOperators
  updatedAt: DateWhereOperators
}

"""Record of a player checking in at a tournament"""
type TournamentCheckIn {
  checkedInAt: DateTime
  checkedInBy: Player
  checkedInById: ID
  createdAt: DateTime!
  enrollment: TournamentEnrollment
  enrollmentId: ID!
  id: ID!
  notes: String
  status: String!
  tournamentEvent: TournamentEvent
  tournamentEventId: ID!
  updatedAt: DateTime
}

"""A TournamentDraw"""
type TournamentDraw {
  createdAt: DateTime!
  entries(args: EntryArgs): [Entry!]

  """Number of entries in this draw"""
  entryCount: Int!
  fallers: Int!
  games(args: GameArgs): [Game!]
  id: ID!
  lastSync: DateTime
  name: String
  risers: Int!
  size: Int
  subeventId: ID
  tournamentSubEvent: TournamentSubEvent
  type: String
  updatedAt: DateTime
  visualCode: String
}

input TournamentDrawArgs {
  order: TournamentDrawSortOrder
  skip: Int = 0
  take: Int
  where: [TournamentDrawWhereInput!]
}

input TournamentDrawSortOrder {
  createdAt: SortDirection
  fallers: SortDirection
  lastSync: SortDirection
  name: SortDirection
  risers: SortDirection
  size: SortDirection
  subeventId: SortDirection
  type: SortDirection
  updatedAt: SortDirection
  visualCode: SortDirection
}

input TournamentDrawWhereInput {
  AND: [TournamentDrawWhereInput!]
  OR: [TournamentDrawWhereInput!]
  createdAt: DateWhereOperators
  fallers: NumberWhereOperators
  lastSync: DateWhereOperators
  name: StringWhereOperators
  risers: NumberWhereOperators
  size: NumberWhereOperators
  subeventId: IdWhereOperators
  type: StringWhereOperators
  updatedAt: DateWhereOperators
  visualCode: StringWhereOperators
}

"""A player enrollment in a tournament sub-event"""
type TournamentEnrollment {
  approvedAt: DateTime
  approvedBy: ID
  approver: Player
  cancelledAt: DateTime
  confirmedAt: DateTime
  confirmedPartner: Player
  confirmedPartnerId: ID
  createdAt: DateTime!
  enrollmentSource: String
  guestEmail: String
  guestName: String
  guestPhone: String
  id: ID!
  isGuest: Boolean!
  notes: String
  originalWaitingListPosition: Int
  player: Player
  playerId: ID
  preferredPartner: Player
  preferredPartnerId: ID
  promotedAt: DateTime
  promotedFromWaitingList: Boolean!
  rejectionReason: String
  requiresApproval: Boolean!
  sessionId: ID
  status: String!
  tournamentSubEvent: TournamentSubEvent
  tournamentSubEventId: ID
  updatedAt: DateTime
  waitingListPosition: Int
  withdrawnAt: DateTime
}

input TournamentEnrollmentArgs {
  order: TournamentEnrollmentSortOrder
  skip: Int = 0
  take: Int
  where: [TournamentEnrollmentWhereInput!]
}

input TournamentEnrollmentSortOrder {
  approvedAt: SortDirection
  approvedBy: SortDirection
  cancelledAt: SortDirection
  confirmedAt: SortDirection
  confirmedPartnerId: SortDirection
  createdAt: SortDirection
  enrollmentSource: SortDirection
  guestEmail: SortDirection
  guestName: SortDirection
  guestPhone: SortDirection
  isGuest: SortDirection
  originalWaitingListPosition: SortDirection
  playerId: SortDirection
  preferredPartnerId: SortDirection
  promotedAt: SortDirection
  promotedFromWaitingList: SortDirection
  rejectionReason: SortDirection
  requiresApproval: SortDirection
  sessionId: SortDirection
  status: SortDirection
  tournamentSubEventId: SortDirection
  updatedAt: SortDirection
  waitingListPosition: SortDirection
  withdrawnAt: SortDirection
}

input TournamentEnrollmentWhereInput {
  AND: [TournamentEnrollmentWhereInput!]
  OR: [TournamentEnrollmentWhereInput!]
  approvedAt: DateWhereOperators
  approvedBy: IdWhereOperators
  cancelledAt: DateWhereOperators
  confirmedAt: DateWhereOperators
  confirmedPartnerId: IdWhereOperators
  createdAt: DateWhereOperators
  enrollmentSource: StringWhereOperators
  guestEmail: StringWhereOperators
  guestName: StringWhereOperators
  guestPhone: StringWhereOperators
  isGuest: BooleanWhereOperators
  originalWaitingListPosition: NumberWhereOperators
  playerId: IdWhereOperators
  preferredPartnerId: IdWhereOperators
  promotedAt: DateWhereOperators
  promotedFromWaitingList: BooleanWhereOperators
  rejectionReason: StringWhereOperators
  requiresApproval: BooleanWhereOperators
  sessionId: IdWhereOperators
  status: StringWhereOperators
  tournamentSubEventId: IdWhereOperators
  updatedAt: DateWhereOperators
  waitingListPosition: NumberWhereOperators
  withdrawnAt: DateWhereOperators
}

"""A TournamentEvent"""
type TournamentEvent {
  allowGuestEnrollments: Boolean!
  closeDate: DateTime
  club: Club
  clubId: String
  country: String
  createdAt: DateTime!
  dates: String
  enrollmentCloseDate: DateTime
  enrollmentOpenDate: DateTime
  firstDay: DateTime
  id: ID!
  lastSync: DateTime
  name: String
  official: Boolean!
  openDate: DateTime
  phase: String!
  schedulePublished: Boolean!
  slug: String
  state: String
  tournamentNumber: String
  tournamentSubEvents(args: TournamentSubEventArgs): [TournamentSubEvent!]
  updatedAt: DateTime
  usedRankingAmount: Int
  usedRankingUnit: String
  visualCode: String
}

input TournamentEventArgs {
  order: TournamentEventSortOrder
  skip: Int = 0
  take: Int
  where: [TournamentEventWhereInput!]
}

input TournamentEventNewInput {
  allowGuestEnrollments: Boolean!
  closeDate: DateTime
  clubId: String
  enrollmentCloseDate: DateTime
  enrollmentOpenDate: DateTime
  firstDay: DateTime

  """Name of the tournament"""
  name: String!
  official: Boolean!
  openDate: DateTime
  schedulePublished: Boolean!
}

input TournamentEventSortOrder {
  allowGuestEnrollments: SortDirection
  closeDate: SortDirection
  clubId: SortDirection
  country: SortDirection
  createdAt: SortDirection
  dates: SortDirection
  enrollmentCloseDate: SortDirection
  enrollmentOpenDate: SortDirection
  firstDay: SortDirection
  lastSync: SortDirection
  name: SortDirection
  official: SortDirection
  openDate: SortDirection
  phase: SortDirection
  schedulePublished: SortDirection
  slug: SortDirection
  state: SortDirection
  tournamentNumber: SortDirection
  updatedAt: SortDirection
  usedRankingAmount: SortDirection
  usedRankingUnit: SortDirection
  visualCode: SortDirection
}

input TournamentEventUpdateInput {
  allowGuestEnrollments: Boolean
  closeDate: DateTime
  enrollmentCloseDate: DateTime
  enrollmentOpenDate: DateTime
  firstDay: DateTime
  name: String
  official: Boolean
  openDate: DateTime
  schedulePublished: Boolean
}

input TournamentEventWhereInput {
  AND: [TournamentEventWhereInput!]
  OR: [TournamentEventWhereInput!]
  allowGuestEnrollments: BooleanWhereOperators
  closeDate: DateWhereOperators
  clubId: StringWhereOperators
  country: StringWhereOperators
  createdAt: DateWhereOperators
  dates: StringWhereOperators
  enrollmentCloseDate: DateWhereOperators
  enrollmentOpenDate: DateWhereOperators
  firstDay: DateWhereOperators
  lastSync: DateWhereOperators
  name: StringWhereOperators
  official: BooleanWhereOperators
  openDate: DateWhereOperators
  phase: StringWhereOperators
  schedulePublished: BooleanWhereOperators
  slug: StringWhereOperators
  state: StringWhereOperators
  tournamentNumber: StringWhereOperators
  updatedAt: DateWhereOperators
  usedRankingAmount: NumberWhereOperators
  usedRankingUnit: StringWhereOperators
  visualCode: StringWhereOperators
}

"""Membership between group and sub-event in tournament"""
type TournamentGroupSubEventMembership {
  createdAt: DateTime!
  groupId: String!
  id: ID!
  isActive: Boolean
  sortOrder: Float
  subEventId: String!
  updatedAt: DateTime
}

"""Phase of a tournament event"""
enum TournamentPhase {
  COMPLETED
  DRAFT
  DRAWS_MADE
  ENROLLMENT_CLOSED
  ENROLLMENT_OPEN
  IN_PROGRESS
  SCHEDULED
}

"""A TournamentSubEvent"""
type TournamentSubEvent {
  allowGuestEnrollments: Boolean!
  autoPromoteFromWaitingList: Boolean!
  confirmedEnrollmentCount: Int!
  createdAt: DateTime!
  currentEnrollmentCount: Int!
  drawTournaments(args: TournamentDrawArgs): [TournamentDraw!]
  enrollmentCloseDate: DateTime
  enrollmentNotes: String
  enrollmentOpenDate: DateTime
  enrollmentPhase: String

  """All enrollments for this sub-event"""
  enrollments(args: TournamentEnrollmentArgs): [TournamentEnrollment!]

  """All entries for this sub-event"""
  entries(args: EntryArgs): [Entry!]

  """Total number of entries"""
  entryCount: Int!
  eventId: String
  eventType: String
  gameType: String
  gameTypeId: Int
  genderId: Int
  id: ID!
  lastSync: DateTime
  levelId: Int
  maxEntries: Int
  maxLevel: Int
  maxWaitingListSize: Int
  minLevel: Int
  name: String
  paraClassId: Int

  """Count of pending enrollments (waiting for partner)"""
  pendingEnrollmentCount: Int!
  requiresApproval: Boolean!
  tournamentEvent: TournamentEvent

  """Entries not yet assigned to any draw"""
  unassignedEntries: [Entry!]

  """Number of entries not yet assigned to a draw"""
  unassignedEntryCount: Int!
  updatedAt: DateTime
  visualCode: String
  waitingListCount: Int
  waitingListEnabled: Boolean!
}

input TournamentSubEventArgs {
  order: TournamentSubEventSortOrder
  skip: Int = 0
  take: Int
  where: [TournamentSubEventWhereInput!]
}

input TournamentSubEventNewInput {
  allowGuestEnrollments: Boolean
  autoPromoteFromWaitingList: Boolean
  confirmedEnrollmentCount: Int
  currentEnrollmentCount: Int
  enrollmentCloseDate: DateTime
  enrollmentNotes: String
  enrollmentOpenDate: DateTime
  enrollmentPhase: String
  eventId: String
  eventType: String
  gameType: String
  gameTypeId: Int
  genderId: Int
  lastSync: DateTime
  levelId: Int
  maxEntries: Int
  maxLevel: Int
  maxWaitingListSize: Int
  minLevel: Int
  name: String
  paraClassId: Int
  requiresApproval: Boolean
  visualCode: String
  waitingListCount: Int
  waitingListEnabled: Boolean
}

input TournamentSubEventSortOrder {
  allowGuestEnrollments: SortDirection
  autoPromoteFromWaitingList: SortDirection
  confirmedEnrollmentCount: SortDirection
  createdAt: SortDirection
  currentEnrollmentCount: SortDirection
  enrollmentCloseDate: SortDirection
  enrollmentNotes: SortDirection
  enrollmentOpenDate: SortDirection
  enrollmentPhase: SortDirection
  eventId: SortDirection
  eventType: SortDirection
  gameType: SortDirection
  gameTypeId: SortDirection
  genderId: SortDirection
  lastSync: SortDirection
  levelId: SortDirection
  maxEntries: SortDirection
  maxLevel: SortDirection
  maxWaitingListSize: SortDirection
  minLevel: SortDirection
  name: SortDirection
  paraClassId: SortDirection
  requiresApproval: SortDirection
  updatedAt: SortDirection
  visualCode: SortDirection
  waitingListEnabled: SortDirection
}

input TournamentSubEventUpdateInput {
  allowGuestEnrollments: Boolean
  autoPromoteFromWaitingList: Boolean
  confirmedEnrollmentCount: Int
  currentEnrollmentCount: Int
  enrollmentCloseDate: DateTime
  enrollmentNotes: String
  enrollmentOpenDate: DateTime
  enrollmentPhase: String
  eventId: String
  eventType: String
  gameType: String
  gameTypeId: Int
  genderId: Int
  id: ID
  lastSync: DateTime
  levelId: Int
  maxEntries: Int
  maxLevel: Int
  maxWaitingListSize: Int
  minLevel: Int
  name: String
  paraClassId: Int
  requiresApproval: Boolean
  visualCode: String
  waitingListCount: Int
  waitingListEnabled: Boolean
}

input TournamentSubEventWhereInput {
  AND: [TournamentSubEventWhereInput!]
  OR: [TournamentSubEventWhereInput!]
  allowGuestEnrollments: BooleanWhereOperators
  autoPromoteFromWaitingList: BooleanWhereOperators
  confirmedEnrollmentCount: NumberWhereOperators
  createdAt: DateWhereOperators
  currentEnrollmentCount: NumberWhereOperators
  enrollmentCloseDate: DateWhereOperators
  enrollmentNotes: StringWhereOperators
  enrollmentOpenDate: DateWhereOperators
  enrollmentPhase: StringWhereOperators
  eventId: StringWhereOperators
  eventType: StringWhereOperators
  gameType: StringWhereOperators
  gameTypeId: NumberWhereOperators
  genderId: NumberWhereOperators
  lastSync: DateWhereOperators
  levelId: NumberWhereOperators
  maxEntries: NumberWhereOperators
  maxLevel: NumberWhereOperators
  maxWaitingListSize: NumberWhereOperators
  minLevel: NumberWhereOperators
  name: StringWhereOperators
  paraClassId: NumberWhereOperators
  requiresApproval: BooleanWhereOperators
  updatedAt: DateWhereOperators
  visualCode: StringWhereOperators
  waitingListEnabled: BooleanWhereOperators
}

input UnmatchedTeamInput {
  clubName: String!
  externalCode: String!
  externalName: String!
  gender: String
  normalizedName: String!
  strength: Int
  teamNumber: Int
}

"""Input for updating an enrollment"""
input UpdateEnrollmentInput {
  """Updated notes"""
  notes: String

  """New preferred partner player ID"""
  preferredPartnerId: ID
}

input UpdateTournamentDrawInput {
  name: String
  size: Int
  type: String
}